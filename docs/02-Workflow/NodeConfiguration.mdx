---
sidebar_position: "3"
title: "Node Configuration"
description: "Description of your new file."
---

Earlier, we covered how to create a workflow and got familiar with the Workflow Editor. Now, let’s take a closer look at how each **node** works.

Inside the editor, you build your workflow by connecting nodes — each representing a specific action, condition, or message step. To add a node, click the `+` icon below an existing one. Then click the node to open its configuration panel.

Each node allows you to define how that step behaves. You can:

- Set static values or attach message templates
- Add conditions, delays, or branching logic
- In **Advanced workflows**, configure nodes dynamically using **variables** with JSON paths

The sections below cover each node type in detail and explain the options available for configuration.

---

# Wait Node

The **Wait Node** lets you pause the workflow before proceeding to the next step. This is useful when you want to introduce a delay or wait until a specific date and time before sending a message or continuing the flow.

When you click on the Wait Node, a configuration panel appears with a **Parameters** tab. Here, you can choose how the wait should be defined:

#### Duration

- Set a fixed delay using:
  - **Days**
  - **Hours**
  - **Minutes**
  - **Seconds**

This option is ideal for introducing consistent gaps between workflow steps.

#### Until

- Define a specific **date and time** when the workflow should resume.
- Select a **Time Zone** to align the timing with the recipient’s or system’s locale.

---

## Additional in Advanced Workflow

In **Advanced workflows**, an extra field appears below the static options:

- **Wait Variable**:
  - A field to enter a dynamic wait value using a JSON path.
  - Example: `{{workflow.data.time}}`

This allows the wait duration to be determined at runtime, based on input data.

> If you use a **Wait Variable**, it will override whatever you set in Duration or Until. Just make sure the variable returns a valid time value — like a number in seconds or a proper date/time — so the workflow knows how long to wait.

---

# Control Nodes

Control nodes help your workflow make decisions and branch based on conditions or variable values. Siren currently supports two types of control nodes:

- [If Node](#if-node) — used for binary conditions (true/false paths)
- [Switch Node](#switch-node) — used for multi-branch routing based on values

## If Node

The **If Node** allows you to define one or more conditions, and split the workflow based on whether the condition(s) evaluate to **true** or **false**.

### Basic Workflow

In a Basic workflow, you can configure only **one condition**.

![If Node - Basic](/assets/images/editor/if-basic.png)

Each condition has the following fields:

- **Value A** – This is the **input source**, typically a JSON path pointing to data pulled from your system, database, or even a prior node.
- **Type** – The expected data type for comparison, such as `STRING`, `NUMBER`, or `BOOLEAN`.
- **Comparison Operator** – How you want to compare the two values. Options include `EQUALS`, `NOT EQUALS`, `GREATER THAN`, etc.
- **Value B** – The **reference value** you're comparing against. This is usually the value entered by the user or a static condition.

If the condition evaluates to true, the workflow continues along the **true** path. Otherwise, it follows the **false** path.

### Advanced Workflow

In an Advanced workflow, the If Node becomes more powerful. You can:

![If Node - Advanced](/assets/images/editor/if-advanced.png)

- Add multiple conditions
- Combine them using **AND** / **OR** logic
- Use dynamic data from external APIs or workflow input using JSON paths

> #### Example
>
> Imagine you're verifying a sensitive action like a payment or login:
>
> - A user submits their **OTP** during the verification process.
> - Your backend fetches the correct OTP from the database and passes it to Siren.
>
> You can configure the **If Node** like this:
>
> - **Value A**: `{workflow.input.user.otp}` (value retrieved from your database)
> - **Type**: `STRING`
> - **Operator**: `EQUALS`
> - **Value B**: `data.user_input_otp` (the OTP the user just entered)
>
> This checks if the submitted OTP matches the stored one.
>
> Now imagine you’ve added an **HTTP Node** earlier in the workflow that fetches fraud risk info for a user.\
> You can use that API’s response too:
>
> - **Value A**: `http.fraud_check.status`
> - **Type**: `STRING`
> - **Operator**: `EQUALS`
> - **Value B**: `approved`
>
> These conditions can then be combined using **AND** logic — so the workflow proceeds only if both checks pass.

---

## Switch Node

The **Switch Node** is used to split the workflow into **multiple paths** based on the value of a variable, similar to a `switch-case` logic in programming.

### Basic Workflow

In Basic mode, the switch has a **Name** field and allows defining up to **9 cases**, including a **default (fallback)** case.

![Switch Node - Basic](/assets/images/editor/switch-basic.png)

- Each case is a **static value**.
- You can route each case to a different set of nodes.
- The **default** route will be used if no match is found.

### Advanced Workflow

In an Advanced workflow, you'll see a **Switch Expression** field instead of a name.

![Switch Node - Advanced](/assets/images/editor/switch-advanced.png)

- Enter a **JSON variable path** (e.g., `data.channel`) to evaluate dynamically.
- Add up to 9 cases to match the expression.
- Just like in Basic mode, one fallback case is always present by default.

> #### Example
>
> Suppose you want to notify users based on their preferred channel.
>
> - Use `data.channel` as your **Switch Expression**
> - Add cases like `email`, `sms`, and `push`
> - Connect each case to the respective channel’s template node
> - Let the fallback case handle any unknown or missing channel values

This allows you to streamline multi-channel workflows in a clean, organized way.

---

# HTTP Node

Use the **HTTP Node** to call an external API during your workflow — for example, to fetch user data, verify an action, or enrich notifications with information from another service.

### Configuration Options

When you add an HTTP Node, you'll see the following fields:

- **Reference Name**\
  A label used to reference this API’s response in later parts of the workflow (e.g., `user_verification`).
- **Continue Workflow on API Failure**\
  If checked, the workflow continues even if the API call fails. Useful for optional or non-blocking requests.
- **Method**\
  Choose the type of HTTP request from the following options:
  - `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`, `HEAD`
- **URL**\
  Enter the **API endpoint link** you want to call.
- **Body**\
  Required for methods like `POST`, `PUT`, or `PATCH`. You can insert variables using JSON path.
- **Content Type**\
  Specifies the format of the request body:
  - `application/json`
  - `text/plain`
  - `text/html`
- **Accept Type**\
  Defines what response format you expect:
  - `application/json`
  - `text/plain`
  - `text/html`
- **Timeouts**
  - **Connection Timeout** – Time (in milliseconds) to wait for a connection to establish.
  - **Read Timeout** – Time (in milliseconds) to wait for the response after the connection is open.
- **Headers**\
  Add custom headers to the request using key-value pairs.

---

### Example

Let’s say you want to check if a user passed a fraud check before sending them a transaction alert.

Here’s how you might configure the HTTP Node:

- **Reference Name**: `fraud_check`
- **Method**: `POST`
- **URL**: `https://api.example.com/verify`
- **Body**:

  ```json
  {
    "userId": "{{data.user_id}}",
    "phone": "{{data.phone_number}}"
  }
  
  ```

---

# Chat Node _(Advanced only)_

Pause the flow to wait for a recipient's response.

- Define the conditions under which the flow should proceed (e.g., on receiving a message).
- Set a timeout after which the workflow will exit or follow an alternate path if no response is received.

---

# Template Node

The **Template Node** is used to send messages using predefined templates across supported channels such as Email, SMS, Push, WhatsApp, and more.

When configuring this node, the available options vary slightly depending on whether the workflow is **Basic** or **Advanced**.

To learn how to create, edit, and manage templates, visit the [Templates](TemplatesOverview) section.

## Basic Workflow

In a Basic workflow:

- The **Parameter** section includes a **Template dropdown**.
- All available templates are listed.
- Templates that share the **same tag** as the workflow will appear **at the top** of the list for quicker access.

You simply select the desired template, and the message will be sent using that configuration.

---

## Advanced Workflow

In an Advanced workflow, the Template Node offers more flexibility:

- A **radio button** lets you choose between:
  - **Static**: Works the same way as Basic — choose a template from the dropdown list.
  - **Dynamic**: Use variables to dynamically select the template and its version during runtime.

Under **Dynamic**, you’ll see the following fields:

- **Template Variable**: Input field where you provide the JSON path to fetch the template name at runtime (e.g., `{{data.template_name}}`).
- **Template Version**: Optional field to specify a particular version of the template if needed.
- **Variable Object Path**: Defines the path to the variables object (e.g., `{{data.vars}}`) that will be substituted into the template during execution.

This makes it possible to personalize which template gets triggered — and what values are passed — based on real-time inputs.

---

# Channel Node

The **Channel Node** lets you send a notification through a specific channel (such as Email, SMS, WhatsApp, etc.) using a configured provider. This is different from the Template Node — here, you manually select the provider and specify recipient details instead of using a predefined template.

---

## Basic Workflow

In a Basic workflow, the configuration is straightforward:

- **Provider**: Select from a dropdown list of available providers for the chosen channel.
- **Wait for Delivery Status**: A checkbox to indicate whether the workflow should pause until a delivery status (e.g., delivered or failed) is returned.

This setup works well when you want to quickly trigger a notification using a static provider and recipient details.

---

## Advanced Workflow

In an Advanced workflow, this node offers more flexibility:

- **Static Mode** (default view):
  - **Provider**: Same as in Basic — select a static provider from the dropdown.
  - **Recipient Field**: Enter the value for the recipient (e.g., Email address, phone number) or use a variable via JSON path (e.g., `{{notify.email}}`).
  - **Wait for Delivery Status**: Same checkbox as in Basic.
- **Dynamic Mode** (enabled via toggle switch):
  When toggled ON, the node supports fully dynamic provider routing:
  - **Provider Integration name or JSON Path**: Input field to define the integration either directly or via a JSON path (e.g., `{{data.provider_name}}`).
  - **Provider (dropdown)**: Still available as a fallback or default.
  - **Recipient Field or JSON Path**: Define where to fetch recipient info dynamically — e.g., `{{notify.sms}}`.
  - **Wait for Delivery Status**: Optional checkbox to enable delivery-based control logic.