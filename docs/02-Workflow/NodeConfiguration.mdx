---
sidebar_position: "3"
title: "Node Configuration"
description: "Description of your new file."
---

Earlier, we covered how to create a workflow and got familiar with the Workflow Editor. Now, let’s take a closer look at how each **node** works.

Inside the editor, you build your workflow by connecting nodes — each representing a specific action, condition, or message step. To add a node, click the `+` icon below an existing one. Then click the node to open its configuration panel.

Each node allows you to define how that step behaves. You can:

- Set static values or attach message templates
- Add conditions, delays, or branching logic
- In **Advanced workflows**, configure nodes dynamically using **variables** with JSON paths

The sections below cover each node type in detail and explain the options available for configuration.

---

# Wait Node

The **Wait Node** lets you pause the workflow before proceeding to the next step. This is useful when you want to introduce a delay or wait until a specific date and time before sending a message or continuing the flow.

When you click on the Wait Node, a configuration panel appears with a **Parameters** tab. Here, you can choose how the wait should be defined:

#### Duration

- Set a fixed delay using:
  - **Days**
  - **Hours**
  - **Minutes**
  - **Seconds**

This option is ideal for introducing consistent gaps between workflow steps.

#### Until

- Define a specific **date and time** when the workflow should resume.
- Select a **Time Zone** to align the timing with the recipient’s or system’s locale.

---

## Additional in Advanced Workflow

In **Advanced workflows**, an extra field appears below the static options:

- **Wait Variable**:
  - A field to enter a dynamic wait value using a JSON path.
  - Example: `{{workflow.data.time}}`

This allows the wait duration to be determined at runtime, based on input data.

> If you use a **Wait Variable**, it will override whatever you set in Duration or Until. Just make sure the variable returns a valid time value — like a number in seconds or a proper date/time — so the workflow knows how long to wait.

---

# Control Nodes

Control nodes help your workflow make decisions and branch based on conditions or variable values. Siren currently supports two types of control nodes:

- [If Node](#if-node) — used for binary conditions (true/false paths)
- [Switch Node](#switch-node) — used for multi-branch routing based on values

## If Node

The **If Node** allows you to define one or more conditions, and split the workflow based on whether the condition(s) evaluate to **true** or **false**.

### Basic Workflow

In a Basic workflow, you can configure only **one condition**.

![If Node - Basic](/assets/images/editor/if-basic.png)

Each condition has the following fields:

- **Value A** – This is the **input source**, typically a JSON path pointing to data pulled from your system, database, or even a prior node.
- **Type** – The expected data type for comparison, such as `STRING`, `NUMBER`, or `BOOLEAN`.
- **Comparison Operator** – How you want to compare the two values. Options include `EQUALS`, `NOT EQUALS`, `GREATER THAN`, etc.
- **Value B** – The **reference value** you're comparing against. This is usually the value entered by the user or a static condition.

If the condition evaluates to true, the workflow continues along the **true** path. Otherwise, it follows the **false** path.

### Advanced Workflow

In an Advanced workflow, the If Node becomes more powerful. You can:

![If Node - Advanced](/assets/images/editor/if-advanced.png)

- Add multiple conditions
- Combine them using **AND** / **OR** logic
- Use dynamic data from external APIs or workflow input using JSON paths

> #### Example
>
> Imagine you're verifying a sensitive action like a payment or login:
>
> - A user submits their **OTP** during the verification process.
> - Your backend fetches the correct OTP from the database and passes it to Siren.
>
> You can configure the **If Node** like this:
>
> - **Value A**: `{workflow.input.user.otp}` (value retrieved from your database)
> - **Type**: `STRING`
> - **Operator**: `EQUALS`
> - **Value B**: `data.user_input_otp` (the OTP the user just entered)
>
> This checks if the submitted OTP matches the stored one.
>
> Now imagine you’ve added an **HTTP Node** earlier in the workflow that fetches fraud risk info for a user.\
> You can use that API’s response too:
>
> - **Value A**: `http.fraud_check.status`
> - **Type**: `STRING`
> - **Operator**: `EQUALS`
> - **Value B**: `approved`
>
> These conditions can then be combined using **AND** logic — so the workflow proceeds only if both checks pass.

---

## Switch Node

The **Switch Node** is used to split the workflow into **multiple paths** based on the value of a variable, similar to a `switch-case` logic in programming.

### Basic Workflow

In Basic mode, the switch has a **Name** field and allows defining up to **9 cases**, including a **default (fallback)** case.

![Switch Node - Basic](/assets/images/editor/switch-basic.png)

- Each case is a **static value**.
- You can route each case to a different set of nodes.
- The **default** route will be used if no match is found.

### Advanced Workflow

In an Advanced workflow, you'll see a **Switch Expression** field instead of a name.

![Switch Node - Advanced](/assets/images/editor/switch-advanced.png)

- Enter a **JSON variable path** (e.g., `data.channel`) to evaluate dynamically.
- Add up to 9 cases to match the expression.
- Just like in Basic mode, one fallback case is always present by default.

> #### Example
>
> Suppose you want to notify users based on their preferred channel.
>
> - Use `data.channel` as your **Switch Expression**
> - Add cases like `email`, `sms`, and `push`
> - Connect each case to the respective channel’s template node
> - Let the fallback case handle any unknown or missing channel values

This allows you to streamline multi-channel workflows in a clean, organized way.

---

# HTTP Node

Use the **HTTP Node** to call an external API during your workflow — for example, to fetch user data, verify an action, or enrich notifications with information from another service.

### Configuration Options

When you add an HTTP Node, you'll see the following fields:

- **Reference Name**\
  A label used to reference this API’s response in later parts of the workflow (e.g., `user_verification`).
- **Continue Workflow on API Failure**\
  If checked, the workflow continues even if the API call fails. Useful for optional or non-blocking requests.
- **Method**\
  Choose the type of HTTP request from the following options:
  - `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`, `HEAD`
- **URL**\
  Enter the **API endpoint link** you want to call.
- **Body**\
  Required for methods like `POST`, `PUT`, or `PATCH`. You can insert variables using JSON path.
- **Content Type**\
  Specifies the format of the request body:
  - `application/json`
  - `text/plain`
  - `text/html`
- **Accept Type**\
  Defines what response format you expect:
  - `application/json`
  - `text/plain`
  - `text/html`
- **Timeouts**
  - **Connection Timeout** – Time (in milliseconds) to wait for a connection to establish.
  - **Read Timeout** – Time (in milliseconds) to wait for the response after the connection is open.
- **Headers**\
  Add custom headers to the request using key-value pairs.

---

### Example

Let’s say you want to check if a user passed a fraud check before sending them a transaction alert.

Here’s how you might configure the HTTP Node:

- **Reference Name**: `fraud_check`
- **Method**: `POST`
- **URL**: `https://api.example.com/verify`
- **Body**:

  ```json
  {
    "userId": "{{data.user_id}}",
    "phone": "{{data.phone_number}}"
  }
  
  ```

---

# Chat Node _(Advanced only)_

Pause the flow to wait for a recipient's response.

- Define the conditions under which the flow should proceed (e.g., on receiving a message).
- Set a timeout after which the workflow will exit or follow an alternate path if no response is received.

---

# Template Node

Send a message using a pre-built template.

- Select a template from your existing list.
- Templates can contain placeholders like `{{data.name}}` which will be replaced using input JSON.
- Templates may include one or more channels (e.g., Email \+ SMS).

---

## Input JSON

In **Advanced workflows**, you can open the **Input JSON** panel from the top-right corner.\
This allows you to:

- View and edit the sample input structure
- Define the `data` and `notify` sections
- Test variable substitution in nodes using this input

Example:

```json
{
  "data": {

  },
  "notify": {
    "email": "priya@example.com",
    "sms": "+919999999999"
  }
}
```